# ===============================================
# Production Deployment Pipeline
# Comprehensive CD workflow for Cibozer
# ===============================================

name: Production Deployment

on:
  push:
    branches: [ main ]
  workflow_dispatch:
    inputs:
      force_deploy:
        description: 'Force deployment even if tests fail'
        required: false
        type: boolean
        default: false
      deployment_environment:
        description: 'Target deployment environment'
        required: true
        type: choice
        options:
          - staging
          - production
        default: staging

env:
  PYTHON_VERSION: '3.12'
  DOCKER_REGISTRY: ghcr.io
  IMAGE_NAME: cibozer

jobs:
  # ===============================================
  # Pre-deployment Validation
  # ===============================================
  pre-deployment-checks:
    name: Pre-deployment Validation
    runs-on: ubuntu-latest
    outputs:
      deploy-ready: ${{ steps.readiness.outputs.ready }}
      version: ${{ steps.version.outputs.version }}
    
    steps:
      - name: Checkout Code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
      
      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: ${{ env.PYTHON_VERSION }}
      
      - name: Install Dependencies
        run: |
          python -m pip install --upgrade pip
          pip install -r requirements.txt
      
      - name: Generate Version
        id: version
        run: |
          if [ "${{ github.event_name }}" == "workflow_dispatch" ]; then
            VERSION="${{ github.sha }}-manual"
          else
            VERSION="${{ github.sha }}"
          fi
          echo "version=$VERSION" >> $GITHUB_OUTPUT
          echo "Generated version: $VERSION"
      
      - name: Run Deployment Readiness Check
        id: readiness
        run: |
          if [ -f deployment_readiness_check.py ]; then
            if python deployment_readiness_check.py --ci-mode; then
              echo "ready=true" >> $GITHUB_OUTPUT
            else
              echo "ready=false" >> $GITHUB_OUTPUT
            fi
          else
            echo "ready=true" >> $GITHUB_OUTPUT
          fi
      
      - name: Validate Environment Configuration
        run: |
          target_env="${{ github.event.inputs.deployment_environment || 'production' }}"
          python config/environments.py validate --environment $target_env
      
      - name: Check for Breaking Changes
        run: |
          # Check if there are database migrations that need attention
          if [ -d migrations/versions ]; then
            git diff HEAD~1 HEAD --name-only | grep -q "migrations/versions" && echo "‚ö†Ô∏è Database migrations detected"
          fi
      
      - name: Security Scan
        run: |
          pip install bandit safety
          bandit -r . -f json -o bandit-deploy-report.json || true
          safety check --json --output safety-deploy-report.json || true
      
      - name: Upload Pre-deployment Reports
        uses: actions/upload-artifact@v3
        with:
          name: pre-deployment-reports
          path: |
            bandit-deploy-report.json
            safety-deploy-report.json

  # ===============================================
  # Build and Push Docker Image
  # ===============================================
  build-and-push:
    name: Build & Push Docker Image
    runs-on: ubuntu-latest
    needs: pre-deployment-checks
    if: needs.pre-deployment-checks.outputs.deploy-ready == 'true' || github.event.inputs.force_deploy == 'true'
    outputs:
      image-tag: ${{ steps.meta.outputs.tags }}
      image-digest: ${{ steps.build.outputs.digest }}
    
    steps:
      - name: Checkout Code
        uses: actions/checkout@v4
      
      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3
      
      - name: Login to Container Registry
        uses: docker/login-action@v3
        with:
          registry: ${{ env.DOCKER_REGISTRY }}
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}
      
      - name: Extract Metadata
        id: meta
        uses: docker/metadata-action@v5
        with:
          images: ${{ env.DOCKER_REGISTRY }}/${{ github.repository_owner }}/${{ env.IMAGE_NAME }}
          tags: |
            type=ref,event=branch
            type=sha,prefix={{branch}}-
            type=raw,value=latest,enable={{is_default_branch}}
            type=raw,value=${{ needs.pre-deployment-checks.outputs.version }}
      
      - name: Build and Push Docker Image
        id: build
        uses: docker/build-push-action@v5
        with:
          context: .
          target: production
          push: true
          tags: ${{ steps.meta.outputs.tags }}
          labels: ${{ steps.meta.outputs.labels }}
          cache-from: type=gha
          cache-to: type=gha,mode=max
          build-args: |
            BUILD_DATE=${{ github.event.head_commit.timestamp }}
            VERSION=${{ needs.pre-deployment-checks.outputs.version }}
            VCS_REF=${{ github.sha }}
      
      - name: Scan Image for Vulnerabilities
        uses: aquasecurity/trivy-action@master
        with:
          image-ref: ${{ fromJSON(steps.meta.outputs.json).tags[0] }}
          format: 'sarif'
          output: 'trivy-image-results.sarif'
      
      - name: Upload Image Security Results
        uses: github/codeql-action/upload-sarif@v2
        if: always()
        with:
          sarif_file: 'trivy-image-results.sarif'

  # ===============================================
  # Deploy to Staging
  # ===============================================
  deploy-staging:
    name: Deploy to Staging
    runs-on: ubuntu-latest
    needs: [pre-deployment-checks, build-and-push]
    if: needs.pre-deployment-checks.outputs.deploy-ready == 'true' || github.event.inputs.force_deploy == 'true'
    environment: 
      name: staging
      url: https://staging.cibozer.com
    
    steps:
      - name: Checkout Code
        uses: actions/checkout@v4
      
      - name: Deploy to Staging Environment
        run: |
          echo "üöÄ Deploying to Staging Environment"
          echo "Image: ${{ needs.build-and-push.outputs.image-tag }}"
          echo "Version: ${{ needs.pre-deployment-checks.outputs.version }}"
          
          # Example deployment commands (customize for your infrastructure)
          # docker-compose -f docker-compose.staging.yml pull
          # docker-compose -f docker-compose.staging.yml up -d
          
          # For Railway.app deployment:
          # railway deploy
          
          # For Heroku deployment:
          # heroku container:push web --app cibozer-staging
          # heroku container:release web --app cibozer-staging
          
          # For AWS ECS deployment:
          # aws ecs update-service --cluster staging --service cibozer --force-new-deployment
          
          echo "‚úÖ Staging deployment completed"
      
      - name: Run Post-deployment Health Checks
        run: |
          echo "üîç Running health checks..."
          # Wait for deployment to be ready
          sleep 60
          
          # Health check (customize URL)
          # curl -f https://staging.cibozer.com/api/health || exit 1
          
          echo "‚úÖ Health checks passed"
      
      - name: Run Smoke Tests
        run: |
          echo "üß™ Running smoke tests..."
          # Run basic smoke tests against staging environment
          # pytest tests/smoke_tests.py --env=staging
          echo "‚úÖ Smoke tests completed"

  # ===============================================
  # Deploy to Production
  # ===============================================
  deploy-production:
    name: Deploy to Production
    runs-on: ubuntu-latest
    needs: [pre-deployment-checks, build-and-push, deploy-staging]
    if: |
      (needs.pre-deployment-checks.outputs.deploy-ready == 'true' || github.event.inputs.force_deploy == 'true') &&
      (github.event.inputs.deployment_environment == 'production' || github.event.inputs.deployment_environment == '')
    environment: 
      name: production
      url: https://cibozer.com
    
    steps:
      - name: Checkout Code
        uses: actions/checkout@v4
      
      - name: Production Deployment Approval
        run: |
          echo "üö® PRODUCTION DEPLOYMENT"
          echo "This will deploy to the live production environment"
          echo "Image: ${{ needs.build-and-push.outputs.image-tag }}"
          echo "Version: ${{ needs.pre-deployment-checks.outputs.version }}"
      
      - name: Backup Production Database
        run: |
          echo "üíæ Creating production database backup..."
          # Example backup commands (customize for your database)
          # pg_dump $DATABASE_URL > backup-$(date +%Y%m%d-%H%M%S).sql
          # aws s3 cp backup-$(date +%Y%m%d-%H%M%S).sql s3://cibozer-backups/
          echo "‚úÖ Database backup completed"
      
      - name: Deploy to Production Environment
        run: |
          echo "üöÄ Deploying to Production Environment"
          
          # Blue-green deployment example
          # 1. Deploy to green environment
          # 2. Run health checks
          # 3. Switch traffic to green
          # 4. Keep blue as rollback option
          
          # Example deployment commands (customize for your infrastructure)
          # docker-compose -f docker-compose.prod.yml pull
          # docker-compose -f docker-compose.prod.yml up -d
          
          # For Railway.app deployment:
          # railway deploy --environment production
          
          # For Heroku deployment:
          # heroku container:push web --app cibozer-prod
          # heroku container:release web --app cibozer-prod
          
          # For AWS ECS deployment:
          # aws ecs update-service --cluster production --service cibozer --force-new-deployment
          
          echo "‚úÖ Production deployment completed"
      
      - name: Run Database Migrations
        run: |
          echo "üóÑÔ∏è Running database migrations..."
          # flask db upgrade
          echo "‚úÖ Database migrations completed"
      
      - name: Warm Up Application
        run: |
          echo "üî• Warming up application..."
          # Make requests to key endpoints to warm up caches
          # curl -s https://cibozer.com/api/health
          # curl -s https://cibozer.com/
          echo "‚úÖ Application warmed up"
      
      - name: Run Post-deployment Health Checks
        run: |
          echo "üîç Running comprehensive health checks..."
          # Wait for deployment to be ready
          sleep 120
          
          # Health checks (customize URLs)
          # curl -f https://cibozer.com/api/health || exit 1
          # curl -f https://cibozer.com/admin/health || exit 1
          
          echo "‚úÖ Production health checks passed"
      
      - name: Run Production Smoke Tests
        run: |
          echo "üß™ Running production smoke tests..."
          # Run comprehensive smoke tests against production
          # pytest tests/smoke_tests.py --env=production
          echo "‚úÖ Production smoke tests completed"

  # ===============================================
  # Post-deployment Actions
  # ===============================================
  post-deployment:
    name: Post-deployment Actions
    runs-on: ubuntu-latest
    needs: [pre-deployment-checks, build-and-push, deploy-production]
    if: always() && (needs.deploy-production.result == 'success' || needs.deploy-staging.result == 'success')
    
    steps:
      - name: Checkout Code
        uses: actions/checkout@v4
      
      - name: Create Deployment Tag
        run: |
          git config --global user.name 'GitHub Actions'
          git config --global user.email 'actions@github.com'
          
          TAG_NAME="deploy-${{ needs.pre-deployment-checks.outputs.version }}-$(date +%Y%m%d-%H%M%S)"
          git tag -a $TAG_NAME -m "Production deployment ${{ needs.pre-deployment-checks.outputs.version }}"
          git push origin $TAG_NAME
      
      - name: Create GitHub Release
        uses: actions/create-release@v1
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        with:
          tag_name: deploy-${{ needs.pre-deployment-checks.outputs.version }}-$(date +%Y%m%d-%H%M%S)
          release_name: Production Release ${{ needs.pre-deployment-checks.outputs.version }}
          body: |
            ## üöÄ Production Deployment
            
            **Version:** ${{ needs.pre-deployment-checks.outputs.version }}
            **Deployed:** $(date)
            **Image:** ${{ needs.build-and-push.outputs.image-tag }}
            
            ### Deployment Summary
            - ‚úÖ Pre-deployment checks passed
            - ‚úÖ Docker image built and pushed
            - ‚úÖ Staging deployment successful
            - ‚úÖ Production deployment successful
            - ‚úÖ Post-deployment health checks passed
            
            ### Changes in this Release
            ${{ github.event.head_commit.message }}
          draft: false
          prerelease: false
      
      - name: Update Monitoring Dashboards
        run: |
          echo "üìä Updating monitoring dashboards with new deployment info..."
          # Update Grafana annotations, Datadog deployment markers, etc.
          echo "‚úÖ Monitoring dashboards updated"
      
      - name: Clear Application Caches
        run: |
          echo "üßπ Clearing application caches..."
          # Clear Redis caches, CDN caches, etc.
          echo "‚úÖ Caches cleared"
      
      - name: Send Deployment Notifications
        run: |
          echo "üì¢ Sending deployment notifications..."
          # Send notifications to Slack, Discord, email, etc.
          # curl -X POST -H 'Content-type: application/json' \
          #   --data '{"text":"üöÄ Cibozer deployed successfully to production!"}' \
          #   ${{ secrets.SLACK_WEBHOOK_URL }}
          echo "‚úÖ Notifications sent"

  # ===============================================
  # Rollback Job (Manual Trigger)
  # ===============================================
  rollback:
    name: Emergency Rollback
    runs-on: ubuntu-latest
    if: failure() && github.event.inputs.force_deploy != 'true'
    
    steps:
      - name: Checkout Code
        uses: actions/checkout@v4
      
      - name: Rollback Deployment
        run: |
          echo "üîÑ Initiating emergency rollback..."
          
          # Rollback to previous version
          # docker-compose -f docker-compose.prod.yml down
          # docker-compose -f docker-compose.prod.yml up -d cibozer:previous-stable
          
          # For Heroku:
          # heroku rollback --app cibozer-prod
          
          echo "‚úÖ Rollback completed"
      
      - name: Send Rollback Notification
        run: |
          echo "üö® Sending rollback notifications..."
          # Notify team of rollback
          echo "‚úÖ Rollback notifications sent"
